1/9:
    1. Initialize the project repository.
    2. Run the PrIntFuzz.
    3. Resolve the dependency bug (incompatible problem in compiler version and cmake version) in PrIntFuzz
    4. Find the config of guest kernel and syzkaller for PCI.
1/10:
    1. Adjust the config of guest kernel and syzkaller to fit our project.
    2. Complete enable_config / printfuzz_get utils
1/11:
    1. Find the emulated device for PCI
    2. Complete qemu command genrator
    3. Complete kernel compile scripts
1/12:
    1. Complete bootstrap script.
    2. Read the first three page of Agamotto paper.
    3. Read the Git document for git submodule, try to build host kernel.
1/13:
    1. Build host kernel
    2. Build guest kernel
    3. Build qemu
    4. Build syzkaller
1/14:
    1. Writing a script for replacing config template!
1/15:
    1. Run the syzkaller, check everything works fine.
1/16:
    1. I found that I am totally wrong to write Perf data to shared memory in guest kernel, It should be the job of guest agent.
    2. Checked the qemu, syzkaller and kernel works fine.
1/17:
    1. Write user agent to obtain LBR sample data from mmap
1/18:
    1. Write perf info to shared memory
1/19:
    1. Building shared memory structure.
1/20:
    1. Complete share memory structure.
    2. Research the relationship between enabled syscall and qemu emulated device in PrIntFuzz project.
1/21:
    1. Get the qemu emulated device list from printfuzz project, knows that which syscalls and devices need to fuzz a driver
1/22:
    1. Got the correlation between driver to syscall and device.
1/23:
    1. I found that the qemu_args key in sys-manager config will replace the "QemuArgs" default value in syzkaller source code,
        which originally provide "-cpu host" option in qemu command
    2. Fix the pci defconfig, which also have the bug " /sys/fuze/connection" as bug file said.
1/24:
    1. Successfully runs the PCI fuzzing
1/25:
    1. Trace the syzkaller executor code, attemp to modify the syscall function to call the perf lib
1/26:
    1. We have to use UIO to handle the ivshmem because we can't know what exactly the sys proc path in guest vm. I find a sample module, and try to understand it.
    2. executor can link my perf_lib
1/27:
    1. The uio driver can't register, so /dev/uio0 not found, keep fixing this problem. 
1/29:
    1. I successfully build the syzkaller to record perf data to ivshmem.
1/30:
    1. research the relationship between i2c & pci & bochs.
1/31:
    1. I found that I totally wrong to use i2c ioctl to call bochs, i2c didn't used in printfuzz, instead they use drm, researching drm. 
2/1:
    1. Successfully invoke bochs driver, but I found I can't write a driver test code for each driver, we should focus on the perf data difference between two test case then try to skip it.
2/2:
    1. Read the agamotto paper.
    2. Trace syzkaller source code to know how the testcase generate.
2/3:
    1. Trace syzkaller source code and agamotto patch to know how did they generate checkpoint between testcases.
2/4:
    1. Keep reading the syzkaller source code, it has 62000 lines .....
2/5:
    1. Read syz-manager and syz-fuzzer
2/6:
    1. The VM for somehow can't run (segmentation fault), building the standard procdure to build the project
    2. I guess the problem is because the scripts/sh/compile/kernel.sh broken, so the host kernel has some problems?
    3. Keep trace syzkaller.
DAILY_TODO:
    1. Find out how kAFL get the base address for each driver, specifically, what is "base address" for a driver.
    2. Research why we need vmcall in perf_agent.
    3. Research the perf usage to accelerate simple program.
    4. The main problem for our project availability is that whether there have any chance to use perf to accelerate driver execution, or the accelerable situation is rare or even not exist.
    5. How to combine the pef data with agamotto checkpoint.
    6. Find out why the lbr entry is so strange.
    7. We still can't compile the syz-description...
