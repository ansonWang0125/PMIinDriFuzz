1/9:
    1. Initialize the project repository.
    2. Run the PrIntFuzz.
    3. Resolve the dependency bug (incompatible problem in compiler version and cmake version) in PrIntFuzz
    4. Find the config of guest kernel and syzkaller for PCI.
1/10:
    1. Adjust the config of guest kernel and syzkaller to fit our project.
    2. Complete enable_config / printfuzz_get utils
1/11:
    1. Find the emulated device for PCI
    2. Complete qemu command genrator
    3. Complete kernel compile scripts
1/12:
    1. Complete bootstrap script.
    2. Read the first three page of Agamotto paper.
    3. Read the Git document for git submodule, try to build host kernel.
1/13:
    1. Build host kernel
    2. Build guest kernel
    3. Build qemu
    4. Build syzkaller
1/14:
    1. Writing a script for replacing config template!
1/15:
    1. Run the syzkaller, check everything works fine.
1/16:
    1. I found that I am totally wrong to write Perf data to shared memory in guest kernel, It should be the job of guest agent.
    2. Checked the qemu, syzkaller and kernel works fine.
1/17:
    1. Write user agent to obtain LBR sample data from mmap
1/18:
    1. Write perf info to shared memory
1/19:
    1. Building shared memory structure.
1/20:
    1. Complete share memory structure.
    2. Research the relationship between enabled syscall and qemu emulated device in PrIntFuzz project.
1/21:
    1. Get the qemu emulated device list from printfuzz project, knows that which syscalls and devices need to fuzz a driver
1/22:
    1. Got the correlation between driver to syscall and device.
1/23:
    1. I found that the qemu_args key in sys-manager config will replace the "QemuArgs" default value in syzkaller source code,
        which originally provide "-cpu host" option in qemu command
    2. Fix the pci defconfig, which also have the bug " /sys/fuze/connection" as bug file said.
1/24:
    1. Successfully runs the PCI fuzzing
1/25:
    1. Trace the syzkaller executor code, attemp to modify the syscall function to call the perf lib
1/26:
    1. We have to use UIO to handle the ivshmem because we can't know what exactly the sys proc path in guest vm. I find a sample module, and try to understand it.
    2. executor can link my perf_lib
1/27:
    1. The uio driver can't register, so /dev/uio0 not found, keep fixing this problem. 
DAILY_TODO:
    1. Find out how kAFL get the base address for each driver, specifically, what is "base address" for a driver.
    2. Create a lib to provide the fuzzer userspace agent to call the perf event and record the perf data to shared memory.
    3. The executor can't link the agent lib in host, find the reason.
    4. Research why we need vmcall in perf_agent.
